// prisma/schema.prisma

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum DiscountType {
  NONE
  PERCENT
}

enum EventType {
  DEAL_VIEW
  MERCHANT_PROFILE_VIEW
}

model Merchant {
  id String @id @default(uuid()) @db.Uuid

  // Link to Supabase auth user (nullable but unique)
  userId String? @unique @db.Uuid

  name        String
  description String?
  avatarUrl   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  category    String?
  address     String?
  city        String?
  phone       String?
  website     String?
  lat         Float?
  lng         Float?

  deals Deal[]

  // ✅ opposite relation for Event.merchant
  events Event[]
}

model Deal {
  id          String @id @default(uuid()) @db.Uuid
  title       String
  description String

  originalPrice Int?

  shortCode String? @unique

  discountValue Int          @default(0)
  discountType  DiscountType @default(NONE)

  imageUrl String?

  // how many times the deal can be redeemed total (null/0 = unlimited)
  maxRedemptions Int?

  startsAt DateTime
  endsAt   DateTime

  merchantId String   @db.Uuid
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  redemptions Redemption[]

  requestedBlockLogs RedemptionBlockLog[] @relation("RequestedDeal")
  blockedBlockLogs   RedemptionBlockLog[] @relation("BlockedDeal")

  // ✅ opposite relation for Event.deal
  events Event[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Redemption {
  id String @id @default(uuid()) @db.Uuid

  dealId String @db.Uuid
  deal   Deal   @relation(fields: [dealId], references: [id])

  code      String @unique
  shortCode String @unique

  redeemedAt DateTime?

  // QR expiry (required)
  expiresAt DateTime

  deviceHash String?
  activeKey  String? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dealId])
  @@index([dealId, redeemedAt])
  @@index([expiresAt])
}

model RedemptionBlockLog {
  id String @id @default(uuid()) @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  deviceHash String @map("device_hash")

  requestedDealId String @map("requested_deal_id") @db.Uuid
  requestedDeal   Deal   @relation("RequestedDeal", fields: [requestedDealId], references: [id], onDelete: Cascade)

  blockedDealId String? @map("blocked_deal_id") @db.Uuid
  blockedDeal   Deal?   @relation("BlockedDeal", fields: [blockedDealId], references: [id], onDelete: SetNull)

  blockedShortCode String?   @map("blocked_short_code")
  blockedExpiresAt DateTime? @map("blocked_expires_at")

  reason String

  retryAfterSec Int?    @map("retry_after_sec")
  userAgent     String? @map("user_agent")

  @@index([createdAt])
  @@index([deviceHash])
  @@index([requestedDealId])
  @@index([blockedDealId])
  @@index([reason])
  @@map("RedemptionBlockLog")
}

model Event {
  id String @id @default(uuid()) @db.Uuid

  type EventType

  /// Your existing cookie-based device value (keep if you want)
  deviceHash String

  /// ✅ NEW: persistent anonymous user id
  visitorId String @db.Uuid
  visitor   VisitorProfile @relation(fields: [visitorId], references: [id], onDelete: Cascade)

  /// ✅ Used for dedupe: unique per visitor/day/target/type
  /// (Keep this: it prevents view spam while still counting unique daily viewers)
  dayKey String @unique @db.VarChar(128)

  merchantId String?   @db.Uuid
  merchant   Merchant? @relation(fields: [merchantId], references: [id], onDelete: SetNull)

  dealId String? @db.Uuid
  deal   Deal?   @relation(fields: [dealId], references: [id], onDelete: SetNull)

  /// Optional metadata (super useful later)
  city        String?
  userAgent   String?
  ipHash      String? // only if you decide to store hashed IP (optional)

  createdAt DateTime @default(now())

  @@index([type, createdAt])
  @@index([visitorId, createdAt])
  @@index([deviceHash, createdAt])
  @@index([merchantId, createdAt])
  @@index([dealId, createdAt])
  @@index([dayKey])
  @@map("Event")
}

model VisitorProfile {
  /// Persistent anonymous ID (UUID string stored in cookie/localStorage)
  id String @id @db.Uuid

  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  /// Optional enrichment (privacy-safe)
  city        String?
  region      String?
  country     String?

  /// Rounded location ONLY (recommended), e.g. 2-3 decimals
  /// - 2 decimals ~ 1.1km
  /// - 3 decimals ~ 110m
  latRound Float?
  lngRound Float?

  /// Optional device fingerprint/hash if you still want it
  deviceHash String?

  /// If user later signs up, link them (optional)
  userId String? @unique @db.Uuid

  /// Relations
  events Event[]

  @@index([lastSeenAt])
  @@index([city])
  @@index([country])
}
